<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - geometry - text</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    html,
    body {
      margin: 0px;
      background-color: black;
    }
  </style>
</head>

<body>

<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src=" https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js">
</script>

<script type="importmap">
{
  "imports": {
    "three": "./libs/threejs/build/three.module.js",
    "three/addons/": "./libs/threejs/jsm/"
  }
}
</script>

<script type="module">

  import * as THREE from 'three';

  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  THREE.Cache.enabled = true;

  let container;

  let camera, cameraTarget, scene, renderer;

  let root, group;
  let satelliteGroup;
  let playerGroup;
  let playerYGroup;
  let modelGroup;
  let meshSphere;
  let modelCamera;
  
  let model;

  let tempObjForRotation;
  let quaternionA = new THREE.Quaternion();
  let quaternionB = new THREE.Quaternion();
  let quaternionM = new THREE.Quaternion();
  let slerpTime = 0;

  let latitude = 20;
  let longitude = 30;

  let keyStatus = {};

  let windowHalfX = window.innerWidth / 2;

  init();
  animate();

  function init() {

    container = document.createElement('div');
    document.body.appendChild(container);

    // CAMERA
    camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 1500);
    camera.position.set(0, 0, 1200);
    // camera.position.set(0, 0, 1000);

    cameraTarget = new THREE.Vector3(0, 0, 0);
    // cameraTarget = new THREE.Vector3(0, 0, 1);

    // SCENE
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 250, 2000);

    // LIGHTS
    const dirLight1 = new THREE.DirectionalLight(0xffffff, 2);
    dirLight1.position.set(1, 0, 1).normalize();
    scene.add(dirLight1);

    const dirLight2 = new THREE.DirectionalLight(0x00ffff, 2);
    dirLight2.position.set(-1, 0, 1).normalize();
    scene.add(dirLight2);

    const dirLight3 = new THREE.DirectionalLight(0xffffff, 2);
    dirLight3.position.set(0, 0, 1).normalize();
    scene.add(dirLight3);

    root = new THREE.Group();
    root.position.y = 0;

    group = new THREE.Group();


    const sphere = (() => {
      const geometry = new THREE.SphereGeometry( 200, 16, 8 ); 
      const material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } ); 
      const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
      return sphere;
    })();

    group.add(sphere);
    
    satelliteGroup = new THREE.Group();
    const satelliteSphere = (() => {
      const geometry = new THREE.SphereGeometry( 40, 16, 8 ); 
      const material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } ); 
      const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
      sphere.position.y = 450;
      return sphere;
    })();
    satelliteGroup.add(satelliteSphere);
    group.add(satelliteGroup);

    scene.add(root);

    root.add(group);
  
    playerGroup = new THREE.Group();
    root.add( playerGroup );
    modelGroup = new THREE.Group();
    // modelGroup.add(camera);
    playerGroup.add(modelGroup);
    playerGroup.rotation.order = "YZX";
    
    // meshSphere = (() => {
    //   const geometry = new THREE.SphereGeometry( 5, 4, 2 ); 
    //   const material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } ); 
    //   const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
    //   sphere.position.y = 150;
    //   sphere.position.z = 50;
    //   return sphere;
    // })();
    // modelGroup.add(meshSphere);

    // modelCamera = (() => {
    //   const geometry = new THREE.SphereGeometry( 5, 4, 2 ); 
    //   const material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } ); 
    //   const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
    //   sphere.position.y = 450;
    //   sphere.position.z = -250;
    //   return sphere;
    // })();
    // modelGroup.add(modelCamera);


    const loader = new GLTFLoader();
    loader.load( './libs/threejs/models/gltf/RobotExpressive/RobotExpressive.glb', function ( gltf ) {
      model = gltf.scene;
      model.position.y = 200;
      model.scale.x = 10;
      model.scale.y = 10;
      model.scale.z = 10;
      // model.rotation.x = -Math.PI / 2;
      modelGroup.add(model);

    }, undefined, function ( e ) {
      console.error( e );
    } );

    // RENDERER

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // EVENTS

    container.style.touchAction = 'none';
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);

    window.addEventListener('resize', onWindowResize);

    renderer.setAnimationLoop(() => {
      satelliteGroup.rotation.x = Date.now() / 5000;
      satelliteGroup.rotation.z = 42;

      
      quaternionM.slerpQuaternions(quaternionA, quaternionB, slerpTime+=0.5);
      playerGroup.quaternion.set(quaternionM.x, quaternionM.y, quaternionM.z, quaternionM.w);
    })
  }

  function onWindowResize() {

    windowHalfX = window.innerWidth / 2;

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

  }

  //

  function animate() {

    requestAnimationFrame(animate);

    render();

  }

  function onKeyDown(event) {
    const keyCode = event.which;
    if (keyCode == 37) keyStatus.left = { pressed: true, ts: Date.now() };
    if (keyCode == 39) keyStatus.right = { pressed: true, ts: Date.now() };
    if (keyCode == 38) keyStatus.up = { pressed: true, ts: Date.now() };
    if (keyCode == 40) keyStatus.down = { pressed: true, ts: Date.now() };
  }

  function onKeyUp(event) {
    const keyCode = event.which;
    if (keyCode == 37) keyStatus.left = null;
    if (keyCode == 39) keyStatus.right = null;
    if (keyCode == 38) keyStatus.up = null;
    if (keyCode == 40) keyStatus.down = null;
  }

  function render() {
    latitude += 0.01;
    longitude += 0.01;
    //*
    // if (model) {
    //   // 구면 위의 좌표 계산
    //   const x = 200 * Math.sin(latitude) * Math.cos(longitude);
    //   const y = 200 * Math.cos(latitude);
    //   const z = 200 * Math.sin(latitude) * Math.sin(longitude);
    //   model.position.set(x, y, z);

    //   // 구면의 표면 법선 벡터를 계산
    //   const normal = model.position.clone().normalize();

    //   // 캐릭터의 방향을 구면의 표면 법선 벡터와 맞추기
    //   model.lookAt(normal);
    // }
    //*/
    
    // root.rotation.y += (1 - root.rotation.y) * 0.05;
    // root.rotation.y += (1 - root.rotation.y) * 0.05;

    // playerGroup.rotation.z += 0.01;
    // playerXGroup.rotation.x += 0.01;
    // playerYGroup.position.x += 0.001;

    //
    // tempObjForRotation = playerGroup.clone();
    // tempObjForRotation.rotation.y = latitude;
    // tempObjForRotation.rotation.z = 40 / 180 * Math.PI;

    // tempObjForRotation.rotation.x = longitude;

    // quaternionA.copy(playerGroup.quaternion); // src quaternion
    // quaternionB.copy(tempObjForRotation.quaternion); // dst quaternion
    // slerpTime = 0;
    //



    // meshSphere.getWorldPosition(cameraTarget);
    // console.log(cameraTarget);

    // modelCamera.getWorldPosition(camera.position)

    // camera.position.set(objectPosition)

    if (model) {
      // model.position.z = 50;


      // const v = new THREE.Vector3();
      // model.getWorldDirection(v);
      // // modelGroup.rotation.set(v.normalize())
      // console.log(v)
      
      // model.position.z = 0

      let x = 0;
      let y = 0;
      if (keyStatus.left) y = -0.01;
      else if (keyStatus.right) y = 0.01;
      if (keyStatus.up) x = -0.01;
      else if (keyStatus.down) x = 0.01;
      

      const quaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(x, y, 0));
    //   sphere.quaternion.rotateTowards(quaternion, 0.05);

    //   const quaternion = new THREE.Quaternion();
    //   quaternion.setFromAxisAngle(new THREE.Vector3(0.4, 1, 0.2).normalize(), 0.01);
      group.quaternion.multiplyQuaternions(quaternion, group.quaternion)


      // tempObjForRotation = playerGroup.clone();
      // const z = Math.atan2(1, 200);
      // const y = Math.atan2(1, 200);
      // tempObjForRotation.rotation.x += z;
      // tempObjForRotation.rotation.y += y;

      // quaternionA.copy(playerGroup.quaternion); // src quaternion
      // quaternionB.copy(tempObjForRotation.quaternion); // dst quaternion
      // slerpTime = 0;
      //
    }


    camera.lookAt(cameraTarget);

    renderer.clear();
    renderer.render(scene, camera);

  }

</script>

</body>

</html>

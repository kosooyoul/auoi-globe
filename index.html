<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - geometry - text</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    html,
    body {
      margin: 0px;
      background-color: black;
    }
  </style>
</head>

<body>

<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src=" https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js">
</script>

<script type="importmap">
{
  "imports": {
    "three": "./libs/threejs/build/three.module.js",
    "three/addons/": "./libs/threejs/jsm/"
  }
}
</script>

<script type="module">

  import * as THREE from 'three';

  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  THREE.Cache.enabled = true;

  let container;

  let camera, cameraTarget, scene, renderer;

  let root, group;
  let satelliteGroup;
  let playerGroup;
  let playerYGroup;
  let modelGroup;
  let meshSphere;
  let modelCamera;
  
  let model;

  let tempObjForRotation;
  let quaternionA = new THREE.Quaternion();
  let quaternionB = new THREE.Quaternion();
  let quaternionM = new THREE.Quaternion();
  let slerpTime = 0;

  let latitude = 20;
  let longitude = 30;

  let keyStatus = {};

  let clock, mixer;
  let previousAction;
  let activeAction;
  let actions;

  let windowHalfX = window.innerWidth / 2;

  init();
  animate();

  function init() {

    clock = new THREE.Clock();

    container = document.createElement('div');
    document.body.appendChild(container);

    // CAMERA
    camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 1500);
    camera.position.set(0, 800, -50);
    // camera.position.set(0, 0, 1000);

    cameraTarget = new THREE.Vector3(0, 0, 0);
    // cameraTarget = new THREE.Vector3(0, 0, 1);

    // SCENE
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 250, 2000);

    // LIGHTS
    const dirLight1 = new THREE.DirectionalLight(0xffffff, 2);
    dirLight1.position.set(1, 0, 1).normalize();
    scene.add(dirLight1);

    const dirLight2 = new THREE.DirectionalLight(0x00ffff, 2);
    dirLight2.position.set(-1, 0, 1).normalize();
    scene.add(dirLight2);

    const dirLight3 = new THREE.DirectionalLight(0xffffff, 2);
    dirLight3.position.set(0, 0, 1).normalize();
    scene.add(dirLight3);

    root = new THREE.Group();
    root.position.y = 0;

    group = new THREE.Group();


    const sphere = (() => {
      const geometry = new THREE.SphereGeometry( 200, 64, 32 ); 
      const material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } ); 
      const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
      return sphere;
    })();

    group.add(sphere);
    
    satelliteGroup = new THREE.Group();
    const satelliteSphere = (() => {
      const geometry = new THREE.SphereGeometry( 40, 24, 12 ); 
      const material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } ); 
      const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
      sphere.position.y = 450;
      return sphere;
    })();
    satelliteGroup.add(satelliteSphere);
    group.add(satelliteGroup);

    scene.add(root);

    root.add(group);
  
    playerGroup = new THREE.Group();
    root.add( playerGroup );
    modelGroup = new THREE.Group();
    // modelGroup.add(camera);
    playerGroup.add(modelGroup);
    playerGroup.rotation.order = "YZX";
    
    // meshSphere = (() => {
    //   const geometry = new THREE.SphereGeometry( 5, 4, 2 ); 
    //   const material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } ); 
    //   const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
    //   sphere.position.y = 150;
    //   sphere.position.z = 50;
    //   return sphere;
    // })();
    // modelGroup.add(meshSphere);

    // modelCamera = (() => {
    //   const geometry = new THREE.SphereGeometry( 5, 4, 2 ); 
    //   const material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } ); 
    //   const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
    //   sphere.position.y = 450;
    //   sphere.position.z = -250;
    //   return sphere;
    // })();
    // modelGroup.add(modelCamera);


    const loader = new GLTFLoader();
    loader.load( './libs/threejs/models/gltf/RobotExpressive/RobotExpressive.glb', function ( gltf ) {
      model = gltf.scene;
      model.position.y = 200;
      model.scale.x = 10;
      model.scale.y = 10;
      model.scale.z = 10;
      // model.rotation.x = -Math.PI / 2;
      modelGroup.add(model);

      // Note: animation settings
      const states = [ 'Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing' ];
      const emotes = [ 'Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp' ];
      mixer = new THREE.AnimationMixer( model );
      actions = [];
      for ( let i = 0; i < gltf.animations.length; i ++ ) {
        const clip = gltf.animations[ i ];
        const action = mixer.clipAction( clip );
        actions[ clip.name ] = action;

        if ( emotes.indexOf( clip.name ) >= 0 || states.indexOf( clip.name ) >= 4 ) {

          action.clampWhenFinished = true;
          action.loop = THREE.LoopOnce;

        }
      }
      activeAction = actions[ 'Idle' ];
      activeAction.play();

    }, undefined, function ( e ) {
      console.error( e );
    } );

    // RENDERER

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // EVENTS

    container.style.touchAction = 'none';
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);

    window.addEventListener('resize', onWindowResize);

    renderer.setAnimationLoop(() => {
      satelliteGroup.rotation.x = Date.now() / 5000;
      satelliteGroup.rotation.z = 42;

      
      quaternionM.slerpQuaternions(quaternionA, quaternionB, slerpTime+=0.5);
      playerGroup.quaternion.set(quaternionM.x, quaternionM.y, quaternionM.z, quaternionM.w);
    })
  }

  function onWindowResize() {

    windowHalfX = window.innerWidth / 2;

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

  }

  function fadeToAction( name, duration ) {
    if ( activeAction == actions[ name ] ) return;

    previousAction = activeAction;
    activeAction = actions[ name ];

    if ( previousAction !== activeAction ) {
      previousAction.fadeOut( duration );
    }

    activeAction
      .reset()
      .setEffectiveTimeScale( 1 )
      .setEffectiveWeight( 1 )
      .fadeIn( duration )
      .play();
  }
  //

  function animate() {

    const dt = clock.getDelta();

    if ( mixer ) mixer.update( dt );

    requestAnimationFrame(animate);

    render();

  }

  function onKeyDown(event) {
    const keyCode = event.which;
    if (keyCode == 37) {
      keyStatus.left = { pressed: true, ts: Date.now() };
      fadeToAction('Walking', 0.2);
    }
    if (keyCode == 39) {
      keyStatus.right = { pressed: true, ts: Date.now() };
      fadeToAction('Walking', 0.2);
    }
    if (keyCode == 38) {
      keyStatus.up = { pressed: true, ts: Date.now() };
      fadeToAction('Walking', 0.2);
    }
    if (keyCode == 40) {
      keyStatus.down = { pressed: true, ts: Date.now() };
      fadeToAction('Walking', 0.2);
    }
    if (keyCode == 13) {
      fadeToAction("Dance", 0.5)
    }
    if (keyCode == 27) {
      fadeToAction("Death", 0.5)
    }
  }

  function onKeyUp(event) {
    const keyCode = event.which;
    if (keyCode == 37) keyStatus.left = null;
    if (keyCode == 39) keyStatus.right = null;
    if (keyCode == 38) keyStatus.up = null;
    if (keyCode == 40) keyStatus.down = null;
    if (keyCode == 13) return;
    if (keyCode == 27) return;
    if (keyStatus.left == null && keyStatus.right == null && keyStatus.up == null && keyStatus.down == null) {
      fadeToAction('Idle', 0.2);
    }
  }

  function render() {
    latitude += 0.01;
    longitude += 0.01;
    //*
    // if (model) {
    //   // 구면 위의 좌표 계산
    //   const x = 200 * Math.sin(latitude) * Math.cos(longitude);
    //   const y = 200 * Math.cos(latitude);
    //   const z = 200 * Math.sin(latitude) * Math.sin(longitude);
    //   model.position.set(x, y, z);

    //   // 구면의 표면 법선 벡터를 계산
    //   const normal = model.position.clone().normalize();

    //   // 캐릭터의 방향을 구면의 표면 법선 벡터와 맞추기
    //   model.lookAt(normal);
    // }
    //*/
    
    // root.rotation.y += (1 - root.rotation.y) * 0.05;
    // root.rotation.y += (1 - root.rotation.y) * 0.05;

    // playerGroup.rotation.z += 0.01;
    // playerXGroup.rotation.x += 0.01;
    // playerYGroup.position.x += 0.001;

    //
    // tempObjForRotation = playerGroup.clone();
    // tempObjForRotation.rotation.y = latitude;
    // tempObjForRotation.rotation.z = 40 / 180 * Math.PI;

    // tempObjForRotation.rotation.x = longitude;

    // quaternionA.copy(playerGroup.quaternion); // src quaternion
    // quaternionB.copy(tempObjForRotation.quaternion); // dst quaternion
    // slerpTime = 0;
    //



    // meshSphere.getWorldPosition(cameraTarget);
    // console.log(cameraTarget);

    // modelCamera.getWorldPosition(camera.position)

    // camera.position.set(objectPosition)

    if (model) {
      // model.position.z = 50;


      // const v = new THREE.Vector3();
      // model.getWorldDirection(v);
      // // modelGroup.rotation.set(v.normalize())
      // console.log(v)
      
      // model.position.z = 0

      let x = 0;
      let y = 0;
      if (keyStatus.left) y = -0.02;
      else if (keyStatus.right) y = 0.02;
      if (keyStatus.up) x = -0.01;
      else if (keyStatus.down) x = 0.01;
      

      const quaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(x, y, 0));
    //   sphere.quaternion.rotateTowards(quaternion, 0.05);

    //   const quaternion = new THREE.Quaternion();
    //   quaternion.setFromAxisAngle(new THREE.Vector3(0.4, 1, 0.2).normalize(), 0.01);
      group.quaternion.multiplyQuaternions(quaternion, group.quaternion)


      // tempObjForRotation = playerGroup.clone();
      // const z = Math.atan2(1, 200);
      // const y = Math.atan2(1, 200);
      // tempObjForRotation.rotation.x += z;
      // tempObjForRotation.rotation.y += y;

      // quaternionA.copy(playerGroup.quaternion); // src quaternion
      // quaternionB.copy(tempObjForRotation.quaternion); // dst quaternion
      // slerpTime = 0;
      //
    }


    camera.lookAt(cameraTarget);

    renderer.clear();
    renderer.render(scene, camera);

  }

</script>

</body>

</html>

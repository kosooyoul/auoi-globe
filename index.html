<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - geometry - text</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    html,
    body {
      margin: 0px;
      background-color: black;
    }
  </style>
</head>

<body>

<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src=" https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js">
</script>

<script type="importmap">
{
  "imports": {
    "three": "./libs/threejs/build/three.module.js",
    "three/addons/": "./libs/threejs/jsm/"
  }
}
</script>

<script type="module">

  import * as THREE from 'three';

  import { FontLoader } from 'three/addons/loaders/FontLoader.js';
  import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

  import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

  THREE.Cache.enabled = true;

  let container;

  let camera, cameraTarget, scene, renderer;

  let root, group;

  let targetRotation = 0;
  let targetRotationOnPointerDown = 0;

  let pointerX = 0;
  let pointerXOnPointerDown = 0;

  let windowHalfX = window.innerWidth / 2;

  init();
  animate();

  function init() {

    container = document.createElement('div');
    document.body.appendChild(container);

    // CAMERA
    camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 1500);
    camera.position.set(0, 0, 1000);
    // camera.position.set(0, 0, 500);

    cameraTarget = new THREE.Vector3(0, 0, 0);
    // cameraTarget = new THREE.Vector3(0, 0, 1);

    // SCENE
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 250, 2000);

    // LIGHTS
    const dirLight1 = new THREE.DirectionalLight(0xffffff, 2);
    dirLight1.position.set(1, 0, 1).normalize();
    scene.add(dirLight1);

    const dirLight2 = new THREE.DirectionalLight(0x00ffff, 2);
    dirLight2.position.set(-1, 0, 1).normalize();
    scene.add(dirLight2);

    const dirLight3 = new THREE.DirectionalLight(0xffffff, 2);
    dirLight3.position.set(0, 0, 1).normalize();
    scene.add(dirLight3);

    root = new THREE.Group();
    root.position.y = 0;

    group = new THREE.Group();


    const sphere = (() => {
      const geometry = new THREE.SphereGeometry( 200, 64, 32 ); 
      const material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } ); 
      const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
      return sphere;
    })();

    group.add(sphere);
    
    const satelliteGroup = new THREE.Group();
    const satelliteSphere = (() => {
      const geometry = new THREE.SphereGeometry( 40, 16, 8 ); 
      const material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } ); 
      const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
      sphere.position.x = 450;
      return sphere;
    })();
    satelliteGroup.add(satelliteSphere);
    group.add(satelliteGroup);

    scene.add(root);

    root.add(group);


    // RENDERER

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // EVENTS

    container.style.touchAction = 'none';
    container.addEventListener('pointerdown', onPointerDown);


    window.addEventListener('resize', onWindowResize);

    setInterval(() => {
      satelliteGroup.rotation.y = Date.now() / 5000;
      satelliteGroup.rotation.x = 12;
    })
  }

  function onWindowResize() {

    windowHalfX = window.innerWidth / 2;

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

  }

  function onPointerDown(event) {

    if (event.isPrimary === false) return;

    pointerXOnPointerDown = event.clientX - windowHalfX;
    targetRotationOnPointerDown = targetRotation;

    document.addEventListener('pointermove', onPointerMove);
    document.addEventListener('pointerup', onPointerUp);

  }

  function onPointerMove(event) {

    if (event.isPrimary === false) return;

    pointerX = event.clientX - windowHalfX;

    targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;

  }

  function onPointerUp() {

    if (event.isPrimary === false) return;

    document.removeEventListener('pointermove', onPointerMove);
    document.removeEventListener('pointerup', onPointerUp);

  }

  //

  function animate() {

    requestAnimationFrame(animate);

    render();

  }

  function render() {

    root.rotation.y += (targetRotation - root.rotation.y) * 0.05;

    camera.lookAt(cameraTarget);

    renderer.clear();
    renderer.render(scene, camera);

  }

</script>

</body>

</html>
